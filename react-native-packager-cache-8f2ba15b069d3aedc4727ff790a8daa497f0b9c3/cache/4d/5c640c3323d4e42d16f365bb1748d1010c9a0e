'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SymbolTreeNode = require('./SymbolTreeNode');
var TreePosition = require('./TreePosition');
var TreeIterator = require('./TreeIterator');

function returnTrue() {
        return true;
}

function reverseArrayIndex(array, reverseIndex) {
        return array[array.length - 1 - reverseIndex];
}

var SymbolTree = function () {
        function SymbolTree(description) {
                _classCallCheck(this, SymbolTree);

                this.symbol = Symbol(description || 'SymbolTree data');
        }

        _createClass(SymbolTree, [{
                key: 'initialize',
                value: function initialize(object) {
                        this._node(object);

                        return object;
                }
        }, {
                key: '_node',
                value: function _node(object) {
                        if (!object) {
                                return null;
                        }

                        var node = object[this.symbol];

                        if (node) {
                                return node;
                        }

                        return object[this.symbol] = new SymbolTreeNode();
                }
        }, {
                key: 'hasChildren',
                value: function hasChildren(object) {
                        return this._node(object).hasChildren;
                }
        }, {
                key: 'firstChild',
                value: function firstChild(object) {
                        return this._node(object).firstChild;
                }
        }, {
                key: 'lastChild',
                value: function lastChild(object) {
                        return this._node(object).lastChild;
                }
        }, {
                key: 'previousSibling',
                value: function previousSibling(object) {
                        return this._node(object).previousSibling;
                }
        }, {
                key: 'nextSibling',
                value: function nextSibling(object) {
                        return this._node(object).nextSibling;
                }
        }, {
                key: 'parent',
                value: function parent(object) {
                        return this._node(object).parent;
                }
        }, {
                key: 'lastInclusiveDescendant',
                value: function lastInclusiveDescendant(object) {
                        var lastChild = void 0;
                        var current = object;

                        while (lastChild = this._node(current).lastChild) {
                                current = lastChild;
                        }

                        return current;
                }
        }, {
                key: 'preceding',
                value: function preceding(object, options) {
                        var treeRoot = options && options.root;

                        if (object === treeRoot) {
                                return null;
                        }

                        var previousSibling = this._node(object).previousSibling;

                        if (previousSibling) {
                                return this.lastInclusiveDescendant(previousSibling);
                        }

                        return this._node(object).parent;
                }
        }, {
                key: 'following',
                value: function following(object, options) {
                        var treeRoot = options && options.root;
                        var skipChildren = options && options.skipChildren;

                        var firstChild = !skipChildren && this._node(object).firstChild;

                        if (firstChild) {
                                return firstChild;
                        }

                        var current = object;

                        do {
                                if (current === treeRoot) {
                                        return null;
                                }

                                var nextSibling = this._node(current).nextSibling;

                                if (nextSibling) {
                                        return nextSibling;
                                }

                                current = this._node(current).parent;
                        } while (current);

                        return null;
                }
        }, {
                key: 'childrenToArray',
                value: function childrenToArray(parent, options) {
                        var array = options && options.array || [];
                        var filter = options && options.filter || returnTrue;
                        var thisArg = options && options.thisArg || undefined;

                        var parentNode = this._node(parent);
                        var object = parentNode.firstChild;
                        var index = 0;

                        while (object) {
                                var node = this._node(object);
                                node.setCachedIndex(parentNode, index);

                                if (filter.call(thisArg, object)) {
                                        array.push(object);
                                }

                                object = node.nextSibling;
                                ++index;
                        }

                        return array;
                }
        }, {
                key: 'ancestorsToArray',
                value: function ancestorsToArray(object, options) {
                        var array = options && options.array || [];
                        var filter = options && options.filter || returnTrue;
                        var thisArg = options && options.thisArg || undefined;

                        var ancestor = object;

                        while (ancestor) {
                                if (filter.call(thisArg, ancestor)) {
                                        array.push(ancestor);
                                }
                                ancestor = this._node(ancestor).parent;
                        }

                        return array;
                }
        }, {
                key: 'treeToArray',
                value: function treeToArray(root, options) {
                        var array = options && options.array || [];
                        var filter = options && options.filter || returnTrue;
                        var thisArg = options && options.thisArg || undefined;

                        var object = root;

                        while (object) {
                                if (filter.call(thisArg, object)) {
                                        array.push(object);
                                }
                                object = this.following(object, { root: root });
                        }

                        return array;
                }
        }, {
                key: 'childrenIterator',
                value: function childrenIterator(parent, options) {
                        var reverse = options && options.reverse;
                        var parentNode = this._node(parent);

                        return new TreeIterator(this, parent, reverse ? parentNode.lastChild : parentNode.firstChild, reverse ? TreeIterator.PREV : TreeIterator.NEXT);
                }
        }, {
                key: 'previousSiblingsIterator',
                value: function previousSiblingsIterator(object) {
                        return new TreeIterator(this, object, this._node(object).previousSibling, TreeIterator.PREV);
                }
        }, {
                key: 'nextSiblingsIterator',
                value: function nextSiblingsIterator(object) {
                        return new TreeIterator(this, object, this._node(object).nextSibling, TreeIterator.NEXT);
                }
        }, {
                key: 'ancestorsIterator',
                value: function ancestorsIterator(object) {
                        return new TreeIterator(this, object, object, TreeIterator.PARENT);
                }
        }, {
                key: 'treeIterator',
                value: function treeIterator(root, options) {
                        var reverse = options && options.reverse;

                        return new TreeIterator(this, root, reverse ? this.lastInclusiveDescendant(root) : root, reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING);
                }
        }, {
                key: 'index',
                value: function index(child) {
                        var childNode = this._node(child);
                        var parentNode = this._node(childNode.parent);

                        if (!parentNode) {
                                return -1;
                        }

                        var currentIndex = childNode.getCachedIndex(parentNode);

                        if (currentIndex >= 0) {
                                return currentIndex;
                        }

                        currentIndex = 0;
                        var object = parentNode.firstChild;

                        if (parentNode.childIndexCachedUpTo) {
                                var cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);
                                object = cachedUpToNode.nextSibling;
                                currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;
                        }

                        while (object) {
                                var node = this._node(object);
                                node.setCachedIndex(parentNode, currentIndex);

                                if (object === child) {
                                        break;
                                }

                                ++currentIndex;
                                object = node.nextSibling;
                        }

                        parentNode.childIndexCachedUpTo = child;

                        return currentIndex;
                }
        }, {
                key: 'childrenCount',
                value: function childrenCount(parent) {
                        var parentNode = this._node(parent);

                        if (!parentNode.lastChild) {
                                return 0;
                        }

                        return this.index(parentNode.lastChild) + 1;
                }
        }, {
                key: 'compareTreePosition',
                value: function compareTreePosition(left, right) {

                        if (left === right) {
                                return 0;
                        }

                        var leftAncestors = [];{
                                var leftAncestor = left;

                                while (leftAncestor) {
                                        if (leftAncestor === right) {
                                                return TreePosition.CONTAINS | TreePosition.PRECEDING;
                                        }

                                        leftAncestors.push(leftAncestor);
                                        leftAncestor = this.parent(leftAncestor);
                                }
                        }

                        var rightAncestors = [];{
                                var rightAncestor = right;

                                while (rightAncestor) {
                                        if (rightAncestor === left) {
                                                return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;
                                        }

                                        rightAncestors.push(rightAncestor);
                                        rightAncestor = this.parent(rightAncestor);
                                }
                        }

                        var root = reverseArrayIndex(leftAncestors, 0);

                        if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {
                                return TreePosition.DISCONNECTED;
                        }

                        var commonAncestorIndex = 0;
                        var ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);

                        for (var i = 0; i < ancestorsMinLength; ++i) {
                                var _leftAncestor = reverseArrayIndex(leftAncestors, i);
                                var _rightAncestor = reverseArrayIndex(rightAncestors, i);

                                if (_leftAncestor !== _rightAncestor) {
                                        break;
                                }

                                commonAncestorIndex = i;
                        }

                        var leftIndex = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));
                        var rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));

                        return rightIndex < leftIndex ? TreePosition.PRECEDING : TreePosition.FOLLOWING;
                }
        }, {
                key: 'remove',
                value: function remove(removeObject) {
                        var removeNode = this._node(removeObject);
                        var parentNode = this._node(removeNode.parent);
                        var prevNode = this._node(removeNode.previousSibling);
                        var nextNode = this._node(removeNode.nextSibling);

                        if (parentNode) {
                                if (parentNode.firstChild === removeObject) {
                                        parentNode.firstChild = removeNode.nextSibling;
                                }

                                if (parentNode.lastChild === removeObject) {
                                        parentNode.lastChild = removeNode.previousSibling;
                                }
                        }

                        if (prevNode) {
                                prevNode.nextSibling = removeNode.nextSibling;
                        }

                        if (nextNode) {
                                nextNode.previousSibling = removeNode.previousSibling;
                        }

                        removeNode.parent = null;
                        removeNode.previousSibling = null;
                        removeNode.nextSibling = null;

                        if (parentNode) {
                                parentNode.childrenChanged();
                        }

                        return removeObject;
                }
        }, {
                key: 'insertBefore',
                value: function insertBefore(referenceObject, newObject) {
                        var referenceNode = this._node(referenceObject);
                        var prevNode = this._node(referenceNode.previousSibling);
                        var newNode = this._node(newObject);
                        var parentNode = this._node(referenceNode.parent);

                        if (newNode.isAttached) {
                                throw Error('Given object is already present in this SymbolTree, remove it first');
                        }

                        newNode.parent = referenceNode.parent;
                        newNode.previousSibling = referenceNode.previousSibling;
                        newNode.nextSibling = referenceObject;
                        referenceNode.previousSibling = newObject;

                        if (prevNode) {
                                prevNode.nextSibling = newObject;
                        }

                        if (parentNode && parentNode.firstChild === referenceObject) {
                                parentNode.firstChild = newObject;
                        }

                        if (parentNode) {
                                parentNode.childrenChanged();
                        }

                        return newObject;
                }
        }, {
                key: 'insertAfter',
                value: function insertAfter(referenceObject, newObject) {
                        var referenceNode = this._node(referenceObject);
                        var nextNode = this._node(referenceNode.nextSibling);
                        var newNode = this._node(newObject);
                        var parentNode = this._node(referenceNode.parent);

                        if (newNode.isAttached) {
                                throw Error('Given object is already present in this SymbolTree, remove it first');
                        }

                        newNode.parent = referenceNode.parent;
                        newNode.previousSibling = referenceObject;
                        newNode.nextSibling = referenceNode.nextSibling;
                        referenceNode.nextSibling = newObject;

                        if (nextNode) {
                                nextNode.previousSibling = newObject;
                        }

                        if (parentNode && parentNode.lastChild === referenceObject) {
                                parentNode.lastChild = newObject;
                        }

                        if (parentNode) {
                                parentNode.childrenChanged();
                        }

                        return newObject;
                }
        }, {
                key: 'prependChild',
                value: function prependChild(referenceObject, newObject) {
                        var referenceNode = this._node(referenceObject);
                        var newNode = this._node(newObject);

                        if (newNode.isAttached) {
                                throw Error('Given object is already present in this SymbolTree, remove it first');
                        }

                        if (referenceNode.hasChildren) {
                                this.insertBefore(referenceNode.firstChild, newObject);
                        } else {
                                newNode.parent = referenceObject;
                                referenceNode.firstChild = newObject;
                                referenceNode.lastChild = newObject;
                                referenceNode.childrenChanged();
                        }

                        return newObject;
                }
        }, {
                key: 'appendChild',
                value: function appendChild(referenceObject, newObject) {
                        var referenceNode = this._node(referenceObject);
                        var newNode = this._node(newObject);

                        if (newNode.isAttached) {
                                throw Error('Given object is already present in this SymbolTree, remove it first');
                        }

                        if (referenceNode.hasChildren) {
                                this.insertAfter(referenceNode.lastChild, newObject);
                        } else {
                                newNode.parent = referenceObject;
                                referenceNode.firstChild = newObject;
                                referenceNode.lastChild = newObject;
                                referenceNode.childrenChanged();
                        }

                        return newObject;
                }
        }]);

        return SymbolTree;
}();

module.exports = SymbolTree;
SymbolTree.TreePosition = TreePosition;