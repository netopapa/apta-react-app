'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TREE = Symbol();
var ROOT = Symbol();
var NEXT = Symbol();
var ITERATE_FUNC = Symbol();

var TreeIterator = function () {
        function TreeIterator(tree, root, firstResult, iterateFunction) {
                _classCallCheck(this, TreeIterator);

                this[TREE] = tree;
                this[ROOT] = root;
                this[NEXT] = firstResult;
                this[ITERATE_FUNC] = iterateFunction;
        }

        _createClass(TreeIterator, [{
                key: 'next',
                value: function next() {
                        var tree = this[TREE];
                        var iterateFunc = this[ITERATE_FUNC];
                        var root = this[ROOT];

                        if (!this[NEXT]) {
                                return {
                                        done: true,
                                        value: root
                                };
                        }

                        var value = this[NEXT];

                        if (iterateFunc === 1) {
                                this[NEXT] = tree._node(value).previousSibling;
                        } else if (iterateFunc === 2) {
                                this[NEXT] = tree._node(value).nextSibling;
                        } else if (iterateFunc === 3) {
                                this[NEXT] = tree._node(value).parent;
                        } else if (iterateFunc === 4) {
                                this[NEXT] = tree.preceding(value, { root: root });
                        } else {
                                        this[NEXT] = tree.following(value, { root: root });
                                }

                        return {
                                done: false,
                                value: value
                        };
                }
        }]);

        return TreeIterator;
}();

Object.defineProperty(TreeIterator.prototype, typeof Symbol === 'function' ? Symbol.iterator : '@@iterator', {
        value: function () {
                return this;
        },
        writable: false
});

TreeIterator.PREV = 1;
TreeIterator.NEXT = 2;
TreeIterator.PARENT = 3;
TreeIterator.PRECEDING = 4;
TreeIterator.FOLLOWING = 5;

Object.freeze(TreeIterator);
Object.freeze(TreeIterator.prototype);

module.exports = TreeIterator;