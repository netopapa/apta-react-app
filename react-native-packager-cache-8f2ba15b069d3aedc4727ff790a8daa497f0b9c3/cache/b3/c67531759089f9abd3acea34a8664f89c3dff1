'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
        function SymbolTreeNode() {
                _classCallCheck(this, SymbolTreeNode);

                this.parent = null;
                this.previousSibling = null;
                this.nextSibling = null;

                this.firstChild = null;
                this.lastChild = null;

                this.childrenVersion = 0;

                this.childIndexCachedUpTo = null;

                this.cachedIndex = -1;
                this.cachedIndexVersion = NaN;
        }

        _createClass(SymbolTreeNode, [{
                key: 'childrenChanged',
                value: function childrenChanged() {
                        this.childrenVersion = this.childrenVersion + 1 & 0xFFFFFFFF;
                        this.childIndexCachedUpTo = null;
                }
        }, {
                key: 'getCachedIndex',
                value: function getCachedIndex(parentNode) {
                        if (this.cachedIndexVersion !== parentNode.childrenVersion) {
                                this.cachedIndexVersion = NaN;

                                return -1;
                        }

                        return this.cachedIndex;
                }
        }, {
                key: 'setCachedIndex',
                value: function setCachedIndex(parentNode, index) {
                        this.cachedIndexVersion = parentNode.childrenVersion;
                        this.cachedIndex = index;
                }
        }, {
                key: 'isAttached',
                get: function get() {
                        return Boolean(this.parent || this.previousSibling || this.nextSibling);
                }
        }, {
                key: 'hasChildren',
                get: function get() {
                        return Boolean(this.firstChild);
                }
        }]);

        return SymbolTreeNode;
}();